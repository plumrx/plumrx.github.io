---
title: TDD实践-向量距离测算
date: 2023-12-07 11:21:41
tags:
---

## 一、TDD是什么？  
测试驱动开发，英文全称是Test-Driven Development，简称为TDD。它要求在编写某个功能的代码**之前**先编写好测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。  


## 二、工作流程  
1. 编写测试用例：在TDD中，首先要为要开发的功能编写测试用例。测试用例描述了功能的预期行为，包括输入和输出。测试用例通常以代码的形式编写，使用适当的测试框架（例如JUnit）来运行测试。
2. 运行测试用例：运行测试用例以验证当前代码的实现是否符合预期。在开始编写功能代码之前，测试用例应该失败，因为尚未编写任何功能代码。
3. 编写功能代码：根据当前测试用例的要求，开始编写功能代码。在此阶段，目标是使测试用例通过。这可能涉及编写新的代码、修改现有代码或者进行重构。
4. 运行测试用例：编写功能代码后，再次运行测试用例，以确保修改的代码仍然通过测试。如果测试用例失败，则需要继续修改代码，直到所有测试用例都通过。
5. 重复迭代：重复上述步骤，为下一个功能点编写新的测试用例，然后编写对应的功能代码。TDD的核心思想是在每个功能点上都遵循这个迭代循环，不断地编写测试用例、编写功能代码并运行测试，以逐步构建出完整的功能。


## 三、实践  
下面以实现向量距离测算功能为例：  
### 红灯阶段  

1. 明确需求：  
本次需要实现的是测算两个向量之间的距离的功能。向量以坐标的形式展现，计算出两向量间绝对距离即可。
> 在开始编写测试用例之前，确保对要开发的功能或特性有清晰的理解和明确的需求。这可以通过与利益相关者进行沟通、阅读需求文档或使用用户故事等方式来实现。  
2. 编写单元测试：  

> TDD的核心是编写单元测试用例。单元测试是对代码中最小可测试单元（通常是函数或方法）的测试。单元测试应该具有独立性和可重复性，并且应该检查功能的各个方面，包括边界条件和异常情况。
3. 运行测试用例：  
> 在编写功能代码之前，运行测试用例以确保它们失败。这是因为尚未编写任何功能代码，所以测试用例应该无法通过。


### 绿灯阶段  
1. 编写功能代码：根据当前测试用例的要求，开始编写功能代码。初始实现可以是简单的占位符代码，只需使测试用例通过即可。这有助于集中注意力并保持迭代的节奏。
2. 运行测试用例：在编写功能代码后，再次运行测试用例以验证实现是否满足预期。测试用例应该能够通过，否则需要进一步修改功能代码。

### 重构阶段  
1. 重构代码：一旦测试用例通过，可以考虑对代码进行重构。重构是指在不改变代码外部行为的情况下改进其内部结构和可读性。通过重构，可以提高代码质量、可维护性和可扩展性。
2. 迭代下一个功能点：完成当前功能的开发后，可以开始下一个功能点的开发。为该功能点编写新的测试用例，然后继续进行功能代码的编写、运行测试用例和重构的循环。


## 四、如何提高效率和质量？  
1. 保持单元测试的快速运行：单元测试应该非常快速，以便可以频繁运行它们。这样可以及早发现问题并快速反馈。
2. 使用断言库和测试框架：使用适当的断言库和测试框架可以简化测试用例的编写和维护工作。这些工具提供了丰富的断言方法和辅助函数，使测试代码更简洁和易于理解。
3. 遵循红-绿-重构原则：在TDD中，红色表示测试失败，绿色表示测试通过，重构表示改进代码质量。遵循这个原则可以确保每个迭代都有明确的目标和方向。
4. 保持测试覆盖率：尽可能覆盖代码的各个路径和边界条件是重要的。通过高测试覆盖率，可以增加对代码质量和功能正确性的信心。
5. 结对编程：TDD与结对编程结合使用可以带来更好的结果。一位开发人员负责编写测试用例，另一位开发人员负责编写功能代码。他们可以互相审查代码、提供反馈并共同确保代码质量。

这些是TDD的一般工作流程和一些实践。使用TDD可以帮助开发人员编写更可靠、可维护和高质量的代码，并提供更好的开发体验。

## 五、最佳实践原则
1. 三角法原则：三角法原则是指在编写测试用例时，首先关注最简单和最具代表性的案例。通过针对这些案例编写测试用例，可以确保代码的最小实现能够满足基本要求。然后，通过添加更多的测试用例来覆盖更多的边界条件和特殊情况。
2. 持续集成：将TDD与持续集成（CI）结合使用可以加快开发流程。持续集成是一种实践，它将开发人员的代码变更自动集成到共享代码仓库，并自动运行测试用例以验证代码的正确性。这样可以快速发现和解决潜在的问题，并确保整个代码库的稳定性。
3. 使用测试桩和模拟：当开发涉及到与外部系统或依赖组件的交互时，可以使用测试桩（Test Stub）和模拟（Mock）来模拟这些外部依赖。测试桩和模拟可以帮助隔离被测试代码的依赖，使测试更加可控和独立。
4. 保持测试的独立性和可读性：测试用例应该是独立的，即一个测试用例的失败不应该影响其他测试用例。此外，测试用例的可读性和可维护性也非常重要。使用清晰的命名、注释和合适的断言可以提高测试代码的可读性。
5. 规范化命名和组织：在编写测试用例时，使用一致且有意义的命名约定。这有助于清晰地表达测试的目的和预期结果。另外，组织测试用例的结构也很重要，可以按照功能、模块或类来组织测试。
6. 整体覆盖测试：除了编写单元测试外，还可以编写整体覆盖测试（End-to-End Test）来验证整个系统的功能和交互。整体覆盖测试可以作为补充，帮助捕捉单元测试无法覆盖的交叉功能和集成问题。
7. 持续反馈和迭代改进：TDD鼓励频繁运行测试用例，以提供快速反馈。利用测试结果和代码覆盖率报告等反馈信息，可以及时发现问题并进行改进。持续反馈和迭代改进是TDD的核心原则之一。
请注意，TDD并不是适用于所有项目和场景的银弹。在某些情况下，TDD可能不切实际或不经济。因此，在实践TDD之前，根据项目的需求和约束条件进行评估，并根据具体情况做出决策。

* "银弹"一词在计算机领域中是一个隐喻，源自于传说中只有银弹才能杀死狼人的故事。在软件开发中，"银弹"指的是一种单一的解决方案或方法，可以完美解决所有问题，没有任何副作用或限制。


每个项目都有其独特的需求、时间限制、团队成员技能和资源限制等因素。有时，TDD可能会增加开发时间和成本，特别是在短期项目或快速原型开发中。在某些情况下，采用其他方法或灵活地调整TDD的实践可能更为适合。因此，在选择是否采用TDD或其他开发方法时，开发团队应该根据具体情况进行评估，并考虑项目的需求、团队的技术能力和资源限制等因素。





















# python-第三方库

## 1.模块和包

### 1.1 模块

一个'*.py' 的文件就是一个模块，能够让你有逻辑的组织你的代码，模块能定义函数、类和变量等。  

### 1.2 包

可以将包理解为一个文件夹，包里必须要有`__init__.py`文件。

### 1.3 python 模块或者包引入的三种形式  
不推荐使用第三种，因为会有很多重名文件。
```commandline
imporrt module[,module2]
from modname import name1[,name2]
from modname import *
```

### 1.4 包的安装  
下载地址：
1. 官方地址： https://pypi.or 
2. 各高校的镜像：阿里云、清华等  

### 1.5 python 常用标准库及第三方库  
覆盖场景：web框架、爬虫、数据库、图片可视化、图片处理、文本处理、自然语言处理、机器学习、代码分析、日志等。  



## 2.常用标注库  
### 2.1 os 模块  
#### 2.1.1 功能
用于访问操作系统相关功能的模块，使用os 模块提供的接口，可以实现跨平台运行。  
#### 2.1.1 os 模块 常用函数  
> import os
1. os.getcwd():获取当前目录
2. os.listdir('.'):列出当前目录下所有文件，包含隐藏文件
2. os.chdir("..."):切换当前目录
3. os.removedirs:递归删除目录
4. os.makedirs('dir1/dir2'):创建多级目录
5. os.remove('filename'):删除文件

#### 2.1.2 os.path 模块常见函数用法  
1. 当前文件可用 __file__ 获取
2. 获取当前文件的绝对路径：os.path.abspath(__file__)
3. 获取文件名：os.path.basename(__file__)
4. 获取当前文件所在目录：os.path.dirname(os.path.absname(__file__))  
先取到文件的绝对路径，再取其上一级目录。

#### 2.1.3 os 模块-执行命令  
1. os.system(command)  
执行结果立马返回，返回结果为：0、-1
```
os.system("ipconfig")
---------------------
Process finished with exit code 0
```
2. popen() 
执行结果不立马返回，可使用 read 方法读取。
```
rsult=os.popen("ipconfig")
print(result)
print(result.read())
----------------------
<os._wrap_close object at 0x000001BAFF4B3450>
Windows IP 配置...
```

#### 2.1.4 os 模块-遍历目录  
1. os.listdir  
适用场景：目录下只有文件，没有文件夹，可以使用该方法。
```commandline
path1="C:\Python311\Lib\json\__pycache__"

for filename in os.listdir(path1):
//join 方法是拼接路径的作用
    print(os.path.join(path1,filename))
--------------------------
C:\Python311\Lib\json\__pycache__\decoder.cpython-311.pyc
C:\Python311\Lib\json\__pycache__\encoder.cpython-311.pyc
C:\Python311\Lib\json\__pycache__\scanner.cpython-311.pyc
C:\Python311\Lib\json\__pycache__\__init__.cpython-311.pyc
```
2. os.walk  
适用场景：目录下不仅有文件，还有文件夹，可以使用该方法。  
该模块返回值是三元元组，各元素如下：  
root:当前正在遍历的文件地址  
dirs:所有子目录  
files:所有文件  
```commandline
for root,dirs,files in os.walk(path2):
    for name in files:
        print(os.path.join(root,name))
    for name in dirs:
        print(os.path.join(root,name))
-----------------------------------------
C:\Python311\Lib\json\decoder.py
C:\Python311\Lib\json\encoder.py
C:\Python311\Lib\json\scanner.py
C:\Python311\Lib\json\tool.py
C:\Python311\Lib\json\__init__.py
C:\Python311\Lib\json\__pycache__
C:\Python311\Lib\json\__pycache__\decoder.cpython-311.pyc
C:\Python311\Lib\json\__pycache__\encoder.cpython-311.pyc
C:\Python311\Lib\json\__pycache__\scanner.cpython-311.pyc
C:\Python311\Lib\json\__pycache__\__init__.cpython-311.pyc
```


### 2.2 sys 模块   

#### 2.2.1 功能  
主要是针对 python 解释器相关的操作，不是主机操作系统。  

#### 2.2.2 常用方法或属性  
1. sys.argv  
是属性，获取当前参数列表，可用于脚本需要外部传递参数时使用。  
```commandline
import sys

# 脚本执行参数列表
# enumerate() 将一个可遍历的数据对象，组合成为一个索引序列，同时累出数据和数据下标
for index, arg in enumerate(sys.argv):
    print("第 %d 个参数是：%s"%(index,arg))

print(sys.argv)
------------------------------
PS D:\project\***> python python-demo.py a b c
第 0 个参数是：python-demo.py
第 1 个参数是：a
第 2 个参数是：b
第 3 个参数是：c
['python-demo.py', 'a', 'b', 'c']
```
2. sys.path  
搜索模块的路径集，返回一个 list。搜索当前环境下python的路径。
```commandline
import sys

for path in sys.path:
    print(path)
----------------------------
C:\Python311\python311.zip
C:\Python311\Lib
C:\Python311\DLLs
C:\Python311
C:\Python311\Lib\site-packages
```

3. 标准输入 sys.stdin & input()    

4. 标准输出 





